<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

</head>
<body>
    <h1>test</h1>
<script>
console.log("1.===============스프레드 연산자");
const a=[1,2,3];
const b=[...a];

b.push(4);
console.log(`a의 값은:${a}`); //1,2,3
console.log(`b의 값은:${b}`); //1,2,3,4 <-a의 값이 변경된후 4추가됨
const c=[...a,4];


console.log("2.===============추가하기");
const a2=[1,2,3];
const b2=a2.concat(4); //concat은 a2값 변경하는 게 아니다.
console.log(`a의 값은:${a2}`); //1,2,3
console.log(`b의 값은:${b2}`); //1,2,3,4
const c2=[...a2,4];
console.log(`c2의 값은:${c2}`); //1,2,3,4

console.log("3.===============걸러내기");
const a3=[1,2,3];
const b3=a3.filter((n)=>{return n!=1;});  //()=>{} 익명함수. n에 첨 1이 들어와서 익명함수실행후, 다시 2가 들어와서 그 반복됨
//filter함수는 boolean을 리턴한다. true만 걸래낸다. 필터는 보통 삭제하기에서 사용
console.log(b3);//2,3

console.log("4.===============짤라내기");
const a4=[1,2,3];
const b4=a4.slice(0,2);
console.log(b4);// <-배열로 출력함. [1,2] 
console.log(`b4의 값은 : ${b4}`); //${b4}<- 값을 출력함. 1,2

console.log("5.===============반복하기");
const a5=[1,2,3,4];
//for(let i=0; i<a5.length; i++){
 //   console.log(a5[i]);
//}

//a5.forEach((n)=>{console.log(n);}); //리턴이 안 되는 것.

//const b5=a5.map((n)=> n);
const b5=a5.map((n)=> {return n;});//위와 동일. {}안 쓰면, 그 줄은 리턴됨.그래서 이때 중괄호 생략가능
// 위는 const b5=[...a5]와 동일

const a6={id:1, name:"jon"};
const b6={...a6,name:"Liz"}; //jon->Liz로 덮어쓰면서 수정됨.
console.log(b6);




const users=[ //5강 첨. 배열 수정하기. 데이터가 여러건 중 하나만 수정할때.
 {id:1, name:"구태모", phone:"2222"},
 {id:2, name:"이대열", phone:"3333"},
 {id:3, name:"오승훈", phone:"4444"}
];

const updateUserDto={
	id:2, name:"홍길동"
}; //이렇게 수정하고 싶을때 어떻게 하나

users[1].name=updateUserDto.name;//이렇게 하면 안된다. 기존 데이타가 변경되서
//const newUser=users.map(u=>u); // const newUser={...users}와 동일
const newUsers=users.map(user=>user.id===updateUserDto.id ? {...user,...updateUserDto} : user); //삼항연산자
// {...user, updateUserDto} 업데이트 하는 것.
console.log("newUsers:", newUsers);


//console.log(users); 


</script>

</body>
</html>